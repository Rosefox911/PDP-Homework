#lang scheme
(require rackunit)
(require rackunit/text-ui)
(require 2htdp/universe)
(require 2htdp/image)
(provide
 run
 make-world)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; DATA DEFINITIONS

;; A MyMouseEvent is a partition of
;; MouseEvent into the following categories:
;; -- "button-down" (interp: object is selected)
;; -- "drag" (interp: drag the object)
;; -- "button-up" (interp: unselect the object)
;; -- any other mouse event (interp: ignored)

;; mev-fn : MyMouseEvent -> ??
;(define (mev-fn mev)
;  (cond
;    [(mouse=? mev "button-down") ...]
;    [(mouse=? mev "drag") ...]
;    [(mouse=? mev "button-up") ...]
;    [else ...]))


;; A MyKeyEvent is a KeyEvent, which is one of
;; -- "r" (interp: r key, creates a new rectangle based on
;;         the target's position)
;; -- any other KeyEvent (interp: ignore)

;; kev-fn : MyKeyEvent -> ??
;(define (kev-fn kev)
;  (cond
;    [(key=? kev "n")
;     ...]
;    [(key=? kev "d")
;     ...]
;    [else
;     ...]))

;; Direction is one of the following:
;; -- "left" (interp: the cat is currently moving left (west on canvas))
;; -- "right" (interp: the cat is currently moving right (east on canvas))
;; NOTE: In practice, the following should happen depending on direction:
;; "left" means the x coordinate is being reduced
;; "right" means the x coordinate is being increased

;; direction-fn : Direction -> ??
;(define (direction-fn dir)
;  [cond
;    [(string=? dir "left")
;     ...]
;    [(string=? dir "right")
;     ...]])

;; END OF DATA DEFINITIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; INTERFACE

(define World<%>
  (interface ()

    ;; -> Void
    ;; EFFECT: updates this World to its state following a tick
    on-tick

    ;; Integer Integer MouseEvent -> Void
    ;; EFFECT: updates this World to its state following the given
    ;; MouseEvent;
    on-mouse

    ;; KeyEvent -> Void
    ;; EFFECT: updates this World to its state following the given
    ;; Key event.
    on-key

    ;; Scene -> Scene
    ;; RETURNS: a Scene like the given one, but with this object drawn
    ;; on it.
    add-to-scene

    ;; -> Number
    ;; RETURN the x and y coordinates of the target
    get-x
    get-y

    ;; -> Boolean
    ;; RETURNS: Is the target selected?
    get-selected?

    ;; -> ListOf<Shape<%>>
    ;; RETURNS: the list of shapes in the world
    get-shapes
    ))

(define Shape<%>
  (interface ()

    ;; -> Void
    ;; EFFECT: updates this Shape to its state following a tick
    on-tick

    ;; Integer Integer MouseEvent -> Void
    ;; EFFECT: updates this Shape to its state following the given
    ;; MouseEvent;
    on-mouse

    ;; KeyEvent -> Void
    ;; EFFECT: updates this Shape to its state following the given
    ;; Key event.
    on-key

    ;; Scene -> Scene
    ;; RETURNS: a Scene like the given one, but with this object drawn
    ;; on it.
    add-to-scene

    ;; -> Number
    ;; RETURN: the x and y coordinates of the center of this shape.
    get-x
    get-y

    ;; -> Boolean
    ;; Is this shape currently selected?
    is-selected?

    ;; -> String
    ;; RETURNS: either "red" or "green", depending on the color in
    ;; which this shape would be displayed if it were displayed now.
    get-color
    ))

;; END OF INTERFACE
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CLASSES
;; A World is a (new World% [x PosInt] [y PosInt]
;;                          [selected? Boolean] [Rectangles ListOf<Rectangle%>]
;;                          [speed PosInt]
;; Interpretation: Represents a world, containing:
;; x representing the x coordinate of the center of the target
;; y representing the y coordinate of the center of the target
;; selected? is a boolean representing whether the target is selected or not
;; rectangles is a ListOf<Rectangle%> representing the list of all rectangles
;; in the world
;; speed represents the amount of pixels traveled by the rectangle on each tick
;; World% -- a class that satisfies the World<%> interface (shown below).


(define World%
  (class* object% (World<%>)
    (init-field x ;; a PosInt, the x coordinate, of the target
                y ;; A PosInt, the y coordinate, of the target
                selected?) ;; A Boolean representing if the
    ;; target is selected or not
    (init-field rectangles) ;; A ListOf<Rectangle%> representing all of
    ;; the rectangles on the board
    (init-field speed) ;; A PosInt, the amount of pixeled traveled by a
    ;; rectangle on each tick

    ;; offsets of mouse click
    (field (x-offset ZERO))
    (field (y-offset ZERO))

    (field [CIRC-IMG CIRCLE-CONSTANT]) ;; A drawing of the circle based on
    ;; radius given by CIRCLE-CONSTANT

    (super-new) ;; creating super class

    ;; on-tick : -> World<%>
    ;; RETURNS: A world that should follow the given world after
    ;; a clock tick
    ;; STRATEGY: HIGHER ORDER FUNCTION COMPOSITION
    (define/public (on-tick)
      (for-each
       ;; Rectangle% -> Rectangle%
       ;; GIVEN: a rectangle
       ;; RETURNS: the rectangle that should follow a clock tick
       ;; STRATEGY: FUNCTIONAL COMPOSITION
       (lambda (rectangle)
         (send rectangle on-tick))
       rectangles))

    ;; on-mouse : PosInt PosInt MyMouseEvent -> World<%>
    ;; GIVEN: a positive integer representing the mouse event's x coordinate
    ;; a positive integer representing the mouse event's y coordinate
    ;; and a mouseevent
    ;; RETURNS: A world that should follow the given MouseEvent
    ;; STRATEGY: STRUCTURAL DECOMPOSITION on mev : MouseEvent
    (define/public (on-mouse mx my mev)
      (cond
        [(mouse=? mev "button-down")
         (send this world-after-button-down mx my mev)]
        [(mouse=? mev "drag")
         (send this world-after-drag mx my mev)]
        [(mouse=? mev "button-up")
         (send this world-after-button-up mx my mev)]
        [else this]))

    ;; world-after-button-down : PosInt PosInt MyMouseEvent -> World<%>
    ;; GIVEN: a positive integer representing the mouse event's x coordinate,
    ;; a positive integer representing the mouse event's y coordinate,
    ;; and a mouse event, in this case, a button-down.
    ;; RETURNS: a world that should follow a button-down mouse event
    ; STRATEGY: HIGHER ORDER FUNCTION COMPOSITION
    (define/public (world-after-button-down mx my mev)
      (if (send this in-circle? mx my)
          (begin
            (set! x-offset (- mx x))
            (set! y-offset (- my y))
            (set! selected? true)
            (send this rect-on-mouse mx my mev))
          (send this rect-on-mouse mx my mev)))

    ;; in-circle : PosInt PosInt -> Boolean
    ;; GIVEN: a PosInt representing the mouse event's x coordinate
    ;; and a PosInt representing the mouse event's y coordinate
    ;; RETURNS: A boolean determining if the mouse event happened
    ;; inside the target circle
    ;; STRATEGY: DOMAIN KNOWLEDGE
    (define/public (in-circle? other-x other-y)
      (<= (+ (sqr (- x other-x)) (sqr (- y other-y)))
          (sqr CIRCLE-RADIUS)))

    ;; world-after-drag : PosInt PosInt MyMouseEvent -> World<%>
    ;; GIVEN: a positive integer representing the mouse event's x coordinate
    ;; a positive integer representing the mouse event's y coordinate
    ;; and a mouse event, in this case, a drag
    ;; RETURNS: a world that should follow a drag mouse event
    ;; STRATEGY: HIGHER ORDER FUNCTION COMPOSITION
    (define/public (world-after-drag mouse-x mouse-y mev)
      (if selected?
          (begin
            (set! x (send this x-helper mouse-x))
            (set! y (send this y-helper mouse-y))
            (send this rect-on-mouse mouse-x mouse-y mev))
          (send this rect-on-mouse mouse-x mouse-y mev)))

    ;; x-helper : PosInt -> PosInt
    ;; GIVEN: a positive integer representing the mouse event's x coordinate
    ;; RETURNS: a postive integer that is either the next position of
    ;; the target
    ;; or the minimum/maximum position ensuring that the target's x coordinate
    ;; does not go outside the canvas
    ;; STRATEGY: DOMAIN KNOWLEDGE
    (define/public (x-helper mouse-x)
      (max CIRCLE-RADIUS
           (min (- CANVAS-WIDTH CIRCLE-RADIUS)
                (+ x-offset mouse-x))))

    ;; y-helper : PosInt -> PosInt
    ;; GIVEN: a positive integer representing the mouse event's y coordinate
    ;; RETURNS: a postive integer that is either the next position of the target
    ;; or the minimum/maximum position ensuring that the target's y coordinate
    ;; does not go outside the canvas
    ;; STRATEGY: DOMAIN KNOWLEDGE
    (define/public (y-helper mouse-y)
      (max CIRCLE-RADIUS
           (min (- CANVAS-HEIGHT CIRCLE-RADIUS)
                (+ y-offset mouse-y))))

    ;; world-after-button-up : PosInt PosInt MyMouseEvent -> World<%>
    ;; GIVEN: a posint representing the mouse event's x coordinate,
    ;; a posint representing the mouse event's y coordinate and a
    ;; mouse event, in this case, a button-up
    ;; RETURNS: the world that should follow the given mouse event,
    ;; in this case, a button-up
    ;; STRATEGY: HIGHER ORDER FUNCTION COMPOSITION
    (define/public (world-after-button-up mx my mev)
      (if selected?
          (begin
            (set! selected? false)
            (send this rect-on-mouse mx my mev))
          (send this rect-on-mouse mx my mev)))

    (define/public (rect-on-mouse mx my mev)
      (for-each
       ;; Rectangle% -> Rectangle%
       ;; GIVEN: a rectangle
       ;; RETURNS: the rectangle that should
       ;; follow a mouse event
       ;; STRATEGY: FUNCTIONAL COMPOSITION
       (lambda (rectangle)
         (send rectangle on-mouse mx my mev))
       rectangles))
    ;; on-key : KeyEvent -> World<%>
    ;; GIVEN: a KeyEvent
    ;; RETURNS: the world that should follow the given KeyEvent
    ;; if the keyevent is r, a new rectangle is created on the target's
    ;; current position. Otherwise, the same world is returned.
    ;; STRATEGY: STRUCTURAL DECOMPOSITION on kev : KeyEvent
    (define/public (on-key kev)
      (cond
        [(key=? kev "r")
         (set! rectangles (local ((define target-x x)
                                  (define target-y y))
                            (if (or (<= (- CANVAS-WIDTH target-x)
                                        RECTANGLE-HALF-WIDTH)
                                    (<= target-x
                                        RECTANGLE-HALF-WIDTH)
                                    (<= target-y
                                        RECTANGLE-HALF-HEIGHT)
                                    (<= (- CANVAS-HEIGHT target-y)
                                        RECTANGLE-HALF-HEIGHT))
                                rectangles
                                (cons
                                 (send this make-rectangle-fn) rectangles))))]
        [else this]))

    ;; make-rectangle : -> Shape<%>
    ;; RETURNS: a Rectangle
    ;; STRATEGY: DOMAIN KNOWLEDGE
    (define/public (make-rectangle-fn)
      (new Rectangle%
        [x x]
        [y y]
        [selected? false]
        [direction "right"]
        [speed speed]))

    ;; add-to-scene : Scene -> Scene
    ;; GIVEN: a scene
    ;; RETURNS: a scene like the original, except
    ;; with the target and rectangles drawn on it
    ;; STRATEGY: HOFC
    (define/public (add-to-scene scene0)
      (local
        ((define scene-with-circle (place-image CIRC-IMG  x y scene0)))
        (foldr
         ;; Rectangle% Scene -> Rectangle%
         ;; GIVEN: a rectangle and a scene
         ;; RETURNS: a scene like the original, except with a rectangle on it
         ;; STRATEGY: FUNCTIONAL COMPOSITION
         (lambda (rectangle scene)
           (send rectangle add-to-scene scene))
         scene-with-circle
         rectangles)))

    ;; get-x : -> PosInt
    ;; RETURNS: the x coordinate of the target circle
    ;; within the world class
    ;; STRATEGY: DOMAIN KNOWLEDGE
    (define/public (get-x)
      x)

    ;; get-y : -> PosInt
    ;; RETURNS: the y coordinate of the target circle
    ;; within the world class
    ;; STRATEGY: DOMAIN KNOWLEDGE
    (define/public (get-y)
      y)

    ;; get-selected? : -> Boolean
    ;; RETURNS: the selected? field of the target circle
    ;; within the world class
    ;; STRATEGY: DOMAIN KNOWLEDGE
    (define/public (get-selected?)
      selected?)

    ;; get-shapes : -> ListOf<Rectangle%>
    ;; RETURNS: the list of rectangles within the world class
    (define/public (get-shapes)
      rectangles)

    ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; A Rectangle is a (new Rectangle% [x PosInt] [y PosInt]
;; [selected? Boolean] [direction Direction]
;; [speed PosInt]
;; Interpretation: Represents a rectangle, containing:
;;  x which is a positive integer, representing the rectangle's x coordinate
;;  y which is a positive integer, representing the rectangle's y coordinate
;;  selected? which is a boolean, representing whether the rectangle is
;; selected or not
;;  direction which is a Direction, representing the direction the
;; rectangle is traveling it.
;;  speed which is a positive integer, representing the pixels the rectangle
;; is moving on each clock tick
;; Rectangle% -- a class that satisfies the Shape<%> interface (shown below)
(define Rectangle%
  (class* object% (Shape<%>)
    (init-field x ;; a PosInt, the x coordinate of the rectangle
                y ;; a PosInt, the y coordinate of the rectangle
                selected?  ;; a Boolean, representing if the rectangle is
                ;; selected or not. (true = selected, false = not)
                direction ;; a Direction, representing the direction the
                ;; direction the rectangle is moving in
                speed) ;; a PosInt, representing the amount of pixels
    ;; the rectangle will move on each clock tick

    (field (RECTANGLE-IMG RECTANGLE-CONSTANT)) ;; Drawing the rectangle based
    ;; on the RECTANGLE-CONSTANT
    ;; constant defined
    (field (RECTANGLE-COLOR "green"))

    ;; offset vector
    (field (x-offset ZERO))
    (field (y-offset ZERO))

    (super-new) ;; creating super class

    ;; on-tick : -> Shape<%>
    ;; RETURNS: A world that should follow the given world after
    ;; a clock tick
    ;; STRATEGY: FUNCTION COMPOSITION
    (define/public (on-tick)
      (if
       selected?
       this
       (send this rectangle-on-tick speed)))

    ;; rectangle-on-tick PosInt -> Shape<%>
    ;; GIVEN: a positive integer, representing the amount of pixels
    ;; the rectangle with travel in a given direction, on each clock tick
    ;; RETURNS: a Rectangle that has been moved
    ;; STRATEGY: STRUCTURAL DECOMPOSITION on direction : Direction
    (define/public (rectangle-on-tick speed)
      (cond
        [(string=? direction "right")
         (send this rectangle-on-tick-right-direction speed)]
        [(string=? direction "left")
         (send this rectangle-on-tick-left-direction speed)]))

    ;; rectangle-on-tick-right-direction : PosInt -> Shape<%>
    ;; GIVEN: a positive integer, representing the amount of pixels
    ;; the rectangle with travel in a given direction, on each clock tick
    ;; RETURNS: a Rectangle that has been moved in the right direction
    ;; STRATEGY: DOMAIN KNOWLEDGE
    (define/public (rectangle-on-tick-right-direction speed)
      (if
       (>= (min (+ x speed) (- CANVAS-WIDTH RECTANGLE-HALF-WIDTH))
           (- CANVAS-WIDTH RECTANGLE-HALF-WIDTH))
       (begin
           (set! x (- CANVAS-WIDTH RECTANGLE-HALF-WIDTH))
            (set! direction "left"))
            (set! x (+ x speed))
            ))

    ;; rectangle-on-tick-left-direction : PosInt -> Shape<%>
    ;; GIVEN: a positive integer, representing the amount of pixels
    ;; the rectangle with travel in a given direction, on each clock tick
    ;; RETURNS: a Rectangle that has been moved in the right direction
    ;; STRATEGY: DOMAIN KNOWLEDGE
    (define/public (rectangle-on-tick-left-direction speed)
      (if
       (<= (max (- x speed) RECTANGLE-HALF-WIDTH) RECTANGLE-HALF-WIDTH)
       (begin (set! x RECTANGLE-HALF-WIDTH)
            (set! direction "right"))
       (set! x (- x speed))))

    ;; on-key : KeyEvent -> Shape<%>
    ;; GIVEN: a KeyEvent
    ;; RETURNS: the rectangle that should follow the given key event
    ;; STRATEGY: DOMAIN KNOWLEDGE
    (define/public (on-key kev)
      this)

    ;; on-mouse PosInt PosInt MyMouseEvent -> Shape<%>
    ;; GIVEN: a positive integer representing the mouse event's x coordinate
    ;; a positive integer representing the mouse event's y coordinate
    ;; and a mouseevent
    ;; RETURNS: A rectangle that should follow the given MouseEvent
    ;; STRATEGY: STRUCTURAL DECOMPOSITION on mev : MyMouseEvent
    (define/public (on-mouse mx my mev)
      (cond
        [(mouse=? mev "button-down")
         (send this rectangle-after-button-down mx my)]
        [(mouse=? mev "drag")
         (send this rectangle-after-drag mx my)]
        [(mouse=? mev "button-up")
         (send this rectangle-after-button-up)]
        [else this]))

    ;; rectangle-after-button-down : PosInt PosInt -> Shape<%>
    ;; GIVEN: a positive integer representing the mouse event's x coordinate,
    ;; and a positive integer representing the mouse event's y coordinate.
    ;; RETURNS: a rectangle that should follow a button-down mouse event
    ; STRATEGY: FUNCTION COMPOSITION
    (define/public (rectangle-after-button-down mx my)
      (if (send this in-rectangle? mx my)
          (begin
            (set! x-offset (- mx x))
            (set! y-offset (- my y))
            (set! selected? true))
          this))

    ;; rectangle-after-drag : PosInt PosInt -> Shape<%>
    ;; GIVEN: a positive integer representing the mouse event's x coordinate,
    ;; and a positive integer representing the mouse event's y coordinate
    ;; RETURNS: a rectangle that should follow a drag mouse event
    ;; STRATEGY: FUNCTION COMPOSITION
    (define/public (rectangle-after-drag mx my)
      (if selected?
          (begin
               (set! x (send this x-helper mx))
               (set! y (send this y-helper my)))
          this))

     ;; x-helper : PosInt -> PosInt
    ;; GIVEN: a positive integer representing the mouse event's x coordinate
    ;; RETURNS: a postive integer that is either the next positive of the target
    ;; or the minimum/maximum position ensuring that the target's x coordinate
    ;; does not go outside the canvas
    ;; STRATEGY: DOMAIN KNOWLEDGE
   (define/public (x-helper mouse-x)
      (max RECTANGLE-HALF-WIDTH
           (min (- CANVAS-WIDTH RECTANGLE-HALF-WIDTH)
                (+ x-offset mouse-x))))

    ;; y-helper : PosInt -> PosInt
    ;; GIVEN: a positive integer representing the mouse event's y coordinate
    ;; RETURNS: a postive integer that is either the next positive of the target
    ;; or the minimum/maximum position ensuring that the target's y coordinate
    ;; does not go outside the canvas
    ;; STRATEGY: DOMAIN KNOWLEDGE
    (define/public (y-helper mouse-y)
      (max RECTANGLE-HALF-HEIGHT
           (min (- CANVAS-HEIGHT RECTANGLE-HALF-HEIGHT)
                (+ y-offset mouse-y))))


    ;; in-rectangle? : PosInt PosInt -> Boolean
    ;; GIVEN: a PosInt representing the mouse event's x coordinate
    ;; and a PosInt representing the mouse event's y coordinate
    ;; RETURNS: A boolean determining if the mouse event happened
    ;; inside the rectangle
    ;; STRATEGY: DOMAIN KNOWLEDGE
    (define/public (in-rectangle? mx my)
      (and
       (<=
        (- x RECTANGLE-HALF-WIDTH)
        mx
        (+ x RECTANGLE-HALF-WIDTH))
       (<=
        (- y RECTANGLE-HALF-HEIGHT)
        my
        (+ y RECTANGLE-HALF-HEIGHT))))

    ;; rectangle-after-button-down : -> Shape<%>
    ;; RETURNS: a rectangle that should follow a button up mouse event
    ;; STRATEGY: DOMAIN KNOWLEDGE
    (define/public (rectangle-after-button-up)
      (set! selected? false))

    ;; add-to-scene : Scene -> Scene
    ;; GIVEN: a scene
    ;; RETURNS: a Scene like the original, except with a rectangle drawn on it
    ;; STRATEGY: DOMAIN KNOWLEDGE
    (define/public (add-to-scene scene)
      (place-image RECTANGLE-IMG x y scene))

    ;; get-x : -> PosInt
    ;; RETURNS: the x coordinate of the rectangle
    ;; within the rectangle class
    ;; STRATEGY: DOMAIN KNOWLEDGE
    (define/public (get-x)
      x)

    ;; get-y : -> PosInt
    ;; RETURNS: the y coordinate of the rectangle
    ;; within the rectangle
    ;; STRATEGY: DOMAIN KNOWLEDGE
    (define/public (get-y)
      y)

    ;; is-selected?  : -> Boolean
    ;; RETURNS: the selected? field of the rectangle
    ;; within the rectangle class
    ;; STRATEGY: DOMAIN KNOWLEDGE
    (define/public (is-selected?)
      selected?)

    (define/public (get-color)
      RECTANGLE-COLOR)
    ))


;; END OF CLASSES
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CONSTANTS

(define CANVAS-WIDTH 400)
(define CANVAS-HEIGHT 500)

(define EMPTY-CANVAS (empty-scene CANVAS-WIDTH CANVAS-HEIGHT))


(define CIRCLE-INITIAL-X 200)
(define CIRCLE-INITIAL-Y 250)

(define RECTANGLE-WIDTH 30)
(define RECTANGLE-HEIGHT 20)

(define RECTANGLE-HALF-WIDTH (/ RECTANGLE-WIDTH 2))
(define RECTANGLE-HALF-HEIGHT (/ RECTANGLE-HEIGHT 2))

(define ZERO 0)

(define RECTANGLE-CONSTANT (rectangle 30 20 "outline" "green"))

(define CIRCLE-CONSTANT (circle 5 "outline" "red"))

(define CIRCLE-RADIUS 5)

(define CONSTANT-SPEED .25)

(define MIN-X-COORDINATE 15)
;; The minimum the rectangle's center x coordinate
;; can be so it stays within canvas.

(define MAX-X-COORDINATE 375)
;; The maximum the rectangle's center x coordinate
;; can be so it stays within canvas.

(define MIN-Y-COORDINATE 10)
;; The minimum the rectangle's center y coordinate
;; can be so it stays within canvas.

(define MAX-Y-COORDINATE 490)
;; The maximum the rectangle's center x coordinate
;; can be so it stays within canvas.

;; END OF CONSTANTS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; make-world : PosInt -> World<%>
;; GIVEN: a PosInt representing the amount of pixels the rectangle will
;; travel on reach clock tick
;; RETURNS: a world with no shapes, but in which any shapes
;; created in the future will travel at the given speed.
;; STRATEGY: DOMAIN KNOWLEDGE
(define (make-world speed)
  (new World%
       [x CIRCLE-INITIAL-X]
       [y CIRCLE-INITIAL-Y]
       [selected? false]
       [rectangles empty]
       [speed speed]))

;; run : PosNum PosInt -> World<%>
;; GIVEN: a PosNum representing a frame rate (in seconds/tick)
;; and a PosInt, representing a shape-speed (in pixels/tick),
;; RETURNS: Returns the final state of the world.
(define (run frame-rate speed)
  (big-bang
   (make-world speed)
   (on-tick (lambda (w) (send w on-tick) w) frame-rate)
   (on-draw (lambda (w) (send w add-to-scene EMPTY-CANVAS)))
   (on-key (lambda (w kev) (send w on-key kev) w))
   (on-mouse (lambda (w mx my mev) (send w on-mouse mx my mev) w))))


